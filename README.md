# Конспект видео про каналы

Структура материала:

-   <a href="https://github.com/pavloging/go-course-channels#вступление">Вступление</a>
-   <a href="https://github.com/pavloging/go-course-channels#какие-свойства-каналов-интерсно-изучить">Какие свойства каналов интересно изучить?</a>
-   <a href="https://github.com/pavloging/go-course-channels#проектирование-каналов">Проектирование каналов</a>
-   <a href="https://github.com/pavloging/go-course-channels#в-какой-области-памяти-хранятся-каналы">В какой области памяти хранятся каналы?</a>
-   <a href="https://github.com/pavloging/go-course-channels#структура-канала">Структура канала</a>
-   <a href="https://github.com/pavloging/go-course-channels#реализация-свойств-goroutine-safe-и-fifo">Реализация свойств: goroutine-safe и FIFO</a>
-   <a href="https://github.com/pavloging/go-course-channels#как-работают-буфер-канала-и-mutex">Как работают буфер канала и mutex</a>
-   <a href="https://github.com/pavloging/go-course-channels#передача-данных-в-канал">Передача данных в канал</a>
-   <a href="https://github.com/pavloging/go-course-channels#получение-данных-из-канала">Получение данных из канала</a>
-   <a href="https://github.com/pavloging/go-course-channels#переполнение-буфера">Переполнение буфера</a>
-   <a href="https://github.com/pavloging/go-course-channels#как-устроен-планировщик-scheduler">Как устроен планировщик (Scheduler)</a>
-   <a href="https://github.com/pavloging/go-course-channels#как-поставить-горутину-на-паузу">Как поставить горутину на паузу</a>
-   <a href="https://github.com/pavloging/go-course-channels#как-разбудить-горутину-очередь-спящих-горутин---sendq">Как разбудить горутину: очередь спящих горутин - sendq</a>
-   <a href="https://github.com/pavloging/go-course-channels#чтение-из-переполненного-канала">Чтение из переполненного канала</a>
-   <a href="https://github.com/pavloging/go-course-channels#пробуждение-спящей-горутины-sender">Пробуждение спящей горутины Sender</a>
-   <a href="https://github.com/pavloging/go-course-channels#чтение-из-пустого-канала">Чтение из пустого канала</a>
-   <a href="https://github.com/pavloging/go-course-channels#передача-данных-прямо-между-стэками-двух-горутин">Передача данных напрямую между стэками двух горутин</a>
-   <a href="https://github.com/pavloging/go-course-channels#небуферизированные-каналы">Небуферизированные каналы</a>
-   <a href="https://github.com/pavloging/go-course-channels#итоги-по-изучению-интерсных-свойств-каналов">Итоги по изучению интересных свойств каналов</a>
-   <a href="https://github.com/pavloging/go-course-channels#изучаем-код-реализации-каналов">Изучаем код реализации каналов</a>
-   <a href="https://github.com/pavloging/go-course-channels#изучаем-поведение-канала-вживую-с-помощью-дебагера">Изучаем поведение канала вживую с помощью дебагера</a>
-   <a href="https://github.com/pavloging/go-course-channels#как-работает-select">Как работает Select</a>
-   <a href="https://github.com/pavloging/go-course-channels#закрытие-канала">Закрытие канала</a>
-   <a href="https://github.com/pavloging/go-course-channels#код-закрытия-канала">Код закрытия канала</a>
-   <a href="https://github.com/pavloging/go-course-channels#итоги-почему-каналы-спроектированны-именно-так">Итоги: почему каналы спроектированы именно так?</a>
-   <a href="https://github.com/pavloging/go-course-channels#заключение">Заключение</a>

## Что такое каналы?

Каналы в Go позволяют писать параллельный код без сложных конструкций, обеспечивая безопасный обмен данными между горутинами и предотвращая гонки данных. Они помогают синхронизировать выполнение горутин, позволяя одной горутине ожидать завершения другой. Каналы создаются с помощью функции make и могут быть буферизованными или небуферизованными, что влияет на их поведение.

## Основные свойства каналов
- Каналы обеспечивают потокобезопасность.
- Они могут хранить элементы и реализовывать семантику FIFO (First In, First Out).
- Каналы могут передавать данные между горутинами и блокировать их.

## Структура канала
- Каналы хранятся в области памяти heap (куча).
- Каналы представляют собой структуру с набором параметров.
- Основные параметры: количество элементов, размер буфера, ссылка на буфер, флаг закрытия, указатели на связанные списки горутин (которые ожидают читения или записи).

Код описывающий структуру каналов:
```go
type hchan struct {
    qcount    uint        // total data in the queue
    dataqsiz  uint        // size of the circular queue
    buf       unsafe.Pointer // points to an array of dataqsiz elements
    elemsize  uint16      // element size
    closed    uint32      // closed status
    elemtype  *_type      // element type
    sendx     uint        // send index
    recvx     uint        // receive index
    recvq     waitq       // list of recv waiters
    sendq     waitq       // list of send waiters

    // lock protects all fields in hchan, as well as several
    // fields in sudogs blocked on this channel.
    //
    // Do not change another G's status while holding this lock
    // (in particular, do not ready a G), as this can deadlock
    // with stack shrinking.
    lock mutex
}

```

## Реализация свойств: goroutine-safe и FIFO

### Потока безопасность и FIFO
- Каналы используют мьютекс для обеспечения потокобезопасности.
- Буфер представляет собой кольцевую очередь для реализации FIFO.
- Индексы ресив и сент указывают на ячейки буфера.

### Что такое мьютекс?
Мьютекс (mutex) — это механизм, который предотвращает одновременный доступ нескольких горутин к общему ресурсу. Он обеспечивает эксклюзивный доступ: когда одна горутина захватывает мьютекс, другие горутины должны ждать, пока он не будет освобожден. Это помогает избежать ошибок и конфликтов при работе с общими данными.

### Запись и чтение данных
- Запись данных происходит в первую ячейку буфера.
- Индекс увеличивается при каждой записи.
- Чтение данных происходит из нулевой ячейки буфера.

## Передача данных в канал
- Send-ер блокирует мьютекс и копирует данные в канал.
- Read-ер блокирует мьютекс и получает данные из очереди.
- Переполнение буфера приводит к блокировке Send-ера.

## Получение данных из канала
1. Будет заблокирован мьютекс
2. Данные будут скопированны из очереди и переданны ресиверу
3. Разблокируем мьютекс

## Переполнение буфера
- Send-ер ставится на паузу, если не может записать данные в буфер.

## Как устроен планировщик (Scheduler)

### Что такое планировщик?
Планировщик — это компонент который управляет выполнением задач или процессов. Планировщик отвечает за распределение горутин (легковесных потоков) по доступным потокам операционной системы. Он решает, когда и какие горутины запускать, обеспечивая эффективное использование ресурсов и параллельное выполнение кода. Это позволяет программам работать более эффективно, особенно на многоядерных процессорах.

- Планировщик управляет переключением контекста между горутинами.

## Как поставить горутину на паузу
1. Функция которая отвечает за отправку в канал вызовет функцию gopark().
Она же на прямую обращается к планировщику, который и изменяет состояние горутины из running в waiting (ожидание). 
2. Далее разрывам связь между горутины и потоком (тредом)
3. Поток (тред) становиться свободным и планировщик отдает новой горутине наш поток

## Как разбудить горутину: очередь спящих горутин - sendq

1. Наша горутина попадает в очередь sendq

Sendq представляет собой ссылку на структуру waitq, а структура waitq хранит ссылки на начало и конец связанного списка.

2. Элементы связанного списка представляют из себя структуру sudog. Грудина попадает в ячейку G, а данные в параметр emel.

3. Read-ер получает данные из очереди, смещая указатель вправо

### Что такое связанный список?
Связанный список — это структура данных, состоящая из узлов, где каждый узел содержит данные и ссылку на следующий узел. Это позволяет добавлять и удалять элементы без необходимости перемещения других элементов, как в массивах. Связанные списки удобны для динамического управления памятью и работы с изменяемыми наборами данных.

## Чтение из переполненного канала
- Ресивер пробуждает спящую грудину, помещая данные в буфер.
- Указатель стека смещается вправо, указывая на следующую ячейку.

## Пробуждение спящей горутины Sender
- Ресивер использует функцию goready() для пробуждения горутины. И меняет состояние спящего горутины на set runnable и тем самым попадает в очередь runq

## Чтение из пустого канала

## Передача данных напрямую между стэками двух горутин

## Небуферизированные каналы

## Итоги по изучению интересных свойств каналов

## Изучаем код реализации каналов

## Изучаем поведение канала вживую с помощью дебагера

## Как работает Select

## Закрытие канала

## Код закрытия канала

## Итоги: почему каналы спроектированны именно так?

## Заключение