# Конспект видео про каналы

Структура материала:

-   <a href="https://github.com/pavloging/go-course-slice#что-такое-каналы">Что такое каналы?</a>
-   <a href="https://github.com/pavloging/go-course-slice#основные-свойства-каналов">Основные свойства каналов</a>
-   <a href="https://github.com/pavloging/go-course-slice#в-какой-области-памяти-хранятся-каналы">В какой области памяти хранятся каналы?</a>
-   <a href="https://github.com/pavloging/go-course-slice#структура-канала">Структура канала</a>
-   <a href="https://github.com/pavloging/go-course-slice#реализация-свойств-goroutine-safe-и-fifo">Реализация свойств: goroutine-safe и FIFO</a>
-   <a href="https://github.com/pavloging/go-course-slice#основные-моменты-goroutine-safe-и-fifo">Основные моменты goroutine-safe и FIFO</a>
-   <a href="https://github.com/pavloging/go-course-slice#что-такое-мьютекс">Что такое мьютекс?</a>
-   <a href="https://github.com/pavloging/go-course-slice#запись-и-чтение-данных">Запись и чтение данных</a>
-   <a href="https://github.com/pavloging/go-course-slice#передача-данных-в-канал">Передача данных в канал</a>
-   <a href="https://github.com/pavloging/go-course-slice#получение-данных-из-канала">Получение данных из канала</a>
-   <a href="https://github.com/pavloging/go-course-slice#переполнение-буфера">Переполнение буфера</a>
-   <a href="https://github.com/pavloging/go-course-slice#как-устроен-планировщик-scheduler">Как устроен планировщик (Scheduler)</a>
-   <a href="https://github.com/pavloging/go-course-slice#как-поставить-горутину-на-паузу">Как поставить горутину на паузу</a>
-   <a href="https://github.com/pavloging/go-course-slice#как-разбудить-горутину-очередь-спящих-горутин-sendq">Как разбудить горутину: очередь спящих горутин - sendq</a>
-   <a href="https://github.com/pavloging/go-course-slice#что-такое-связанный-список">Что такое связанный список?</a>
-   <a href="https://github.com/pavloging/go-course-slice#чтение-из-переполненного-канала">Чтение из переполненного канала</a>
-   <a href="https://github.com/pavloging/go-course-slice#пробуждение-спящей-горутины-sender">Пробуждение спящей горутины Sender</a>
-   <a href="https://github.com/pavloging/go-course-slice#чтение-из-пустого-канала">Чтение из пустого канала</a>
-   <a href="https://github.com/pavloging/go-course-slice#передача-данных-прямо-между-стеками-двух-горутин">Передача данных напрямую между стэками двух горутин</a>
-   <a href="https://github.com/pavloging/go-course-slice#небуферизированные-каналы">Небуферизированные каналы</a>
-   <a href="https://github.com/pavloging/go-course-slice#преимущества-небуферизированных-каналов">Преимущества небуферизированных каналов</a>
-   <a href="https://github.com/pavloging/go-course-slice#итоги-по-изучению-интересных-свойств-каналов">Итоги по изучению интересных свойств каналов</a>
-   <a href="https://github.com/pavloging/go-course-slice#как-работает-select">Как работает Select</a>
-   <a href="https://github.com/pavloging/go-course-slice#закрытие-канала">Закрытие канала</a>
-   <a href="https://github.com/pavloging/go-course-slice#итоги-почему-каналы-спроектированны-именно-так">Итоги: почему каналы спроектированы именно так?</a>

## Что такое каналы?

Каналы в Go позволяют писать параллельный код без сложных конструкций, обеспечивая безопасный обмен данными между горутинами и предотвращая гонки данных. Они помогают синхронизировать выполнение горутин, позволяя одной горутине ожидать завершения другой. Каналы создаются с помощью функции make и могут быть буферизованными или небуферизованными, что влияет на их поведение.

## Основные свойства каналов

-   Каналы обеспечивают потокобезопасность.
-   Они могут хранить элементы и реализовывать семантику FIFO (First In, First Out).
-   Каналы могут передавать данные между горутинами и блокировать их.

## В какой области памяти хранятся каналы?

-   Каналы хранятся в области памяти heap (куча).

## Структура канала

-   Каналы представляют собой структуру с набором параметров.
-   Основные параметры: количество элементов, размер буфера, ссылка на буфер, флаг закрытия, указатели на связанные списки горутин (которые ожидают читения или записи).

Код описывающий структуру каналов:

```go
type hchan struct {
    qcount    uint        // total data in the queue
    dataqsiz  uint        // size of the circular queue
    buf       unsafe.Pointer // points to an array of dataqsiz elements
    elemsize  uint16      // element size
    closed    uint32      // closed status
    elemtype  *_type      // element type
    sendx     uint        // send index
    recvx     uint        // receive index
    recvq     waitq       // list of recv waiters
    sendq     waitq       // list of send waiters

    // lock protects all fields in hchan, as well as several
    // fields in sudogs blocked on this channel.
    //
    // Do not change another G's status while holding this lock
    // (in particular, do not ready a G), as this can deadlock
    // with stack shrinking.
    lock mutex
}

```

## Реализация свойств: goroutine-safe и FIFO

Реализация свойств Goroutine-safe и FIFO (first-in, first-out) в Go достигается с помощью каналов и буферизованных структур данных.

## Основные моменты goroutine-safe и FIFO

1. Goroutine-safe:

    - Каналы в Go являются безопасными для работы с многопоточностью. Это означает, что несколько горутин могут одновременно отправлять и получать данные из одного канала без необходимости использования дополнительных механизмов синхронизации.
    - При отправке и получении данных каналы автоматически блокируют горутины, что предотвращает гонки данных.

2. FIFO:
    - Каналы реализуют принцип FIFO, что означает, что данные, отправленные в канал, будут получены в том порядке, в котором они были отправлены.
    - Например, если первая горутина отправляет значение, а затем вторая, первая горутина получит свое значение первой, когда данные будут извлечены из канала.

Пример:

```go
ch := make(chan int)

go func() {
    ch <- 1 // отправка первого значения
}()
go func() {
    ch <- 2 // отправка второго значения
}()

fmt.Println(<-ch) // получаем 1
fmt.Println(<-ch) // получаем 2
```

## Что такое мьютекс?

Мьютекс (mutex) — это механизм, который предотвращает одновременный доступ нескольких горутин к общему ресурсу.

Он обеспечивает эксклюзивный доступ: когда одна горутина захватывает мьютекс, другие горутины должны ждать, пока он не будет освобожден. Это помогает избежать ошибок и конфликтов при работе с общими данными.

## Запись и чтение данных

-   Запись данных происходит в первую ячейку буфера.
-   Индекс увеличивается при каждой записи.
-   Чтение данных происходит из нулевой ячейки буфера.

Пример:

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan int)

    go func() {
        ch <- 42 // запись данных в канал
    }()

    value := <-ch // чтение данных из канала
    fmt.Println(value) // вывод: 42
}

```

## Передача данных в канал

Передача данных в канал в Go — это процесс отправки значений из одной горутины в другую с помощью каналов, которые обеспечивают безопасный обмен данными.

_По уроку:_
_Send-ер блокирует мьютекс и копирует данные в канал._
_Read-ер блокирует мьютекс и получает данные из очереди._
_Переполнение буфера приводит к блокировке Send-ера._

Пример:

```go
// Для передачи данных в канал используется оператор отправки
ch <- value
```

## Получение данных из канала

Получение данных из канала — это процесс извлечения значения из канала, который используется для обмена данными между горутинами.

_По уроку:_
_1. Будет заблокирован мьютекс_
_2. Данные будут скопированны из очереди и переданны ресиверу_
_3. Разблокируем мьютекс_

Пример:

```go
// Для получения данных из канала используется операция value := <-ch, где value будет содержать извлеченное значение.
value := <-ch
```

## Переполнение буфера

Переполнение буфера — это ошибка, возникающая, когда программа записывает больше данных в буфер, чем он может вместить. Это может привести к повреждению данных, сбоям программы или уязвимостям в безопасности, таким как выполнение произвольного кода.

_По уроку:_
_Send-ер ставится на паузу, если не может записать данные в буфер._

## Как устроен планировщик (Scheduler)

Планировщик — это компонент который управляет выполнением задач или процессов. Планировщик отвечает за распределение горутин (легковесных потоков) по доступным потокам операционной системы. Он решает, когда и какие горутины запускать, обеспечивая эффективное использование ресурсов и параллельное выполнение кода. Это позволяет программам работать более эффективно, особенно на многоядерных процессорах.

-   Планировщик управляет переключением контекста между горутинами.

## Как поставить горутину на паузу

Можно контролировать выполнение горутины с помощью каналов, sync.WaitGroup, или использование контекста.

Пример с использованием каналов:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    pauseChan := make(chan struct{})

    go func() {
        for i := 0; i < 5; i++ {
            fmt.Println("Горутина работает:", i)
            time.Sleep(1 * time.Second)
            if i == 2 {
                fmt.Println("Горутина приостановлена.")
                <-pauseChan // Ожидание сигнала для продолжения
                fmt.Println("Горутина продолжает работу.")
            }
        }
    }()

    time.Sleep(3 * time.Second) // Ждем, пока горутина дойдет до паузы
    close(pauseChan) // Сигнализируем горутине продолжить

    // Ожидание завершения
    time.Sleep(5 * time.Second)
}

```

Пример с использованием sync.WaitGroup:

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var wg sync.WaitGroup
    wg.Add(1)

    go func() {
        defer wg.Done()
        for i := 0; i < 5; i++ {
            fmt.Println("Горутина работает:", i)
            time.Sleep(1 * time.Second)
            if i == 2 {
                fmt.Println("Горутина приостановлена.")
                time.Sleep(3 * time.Second) // Имитация паузы
                fmt.Println("Горутина продолжает работу.")
            }
        }
    }()

    wg.Wait() // Ожидание завершения горутины
}

```

Пример с использованием контекста:

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())

    go func() {
        for i := 0; i < 5; i++ {
            select {
            case <-ctx.Done():
                fmt.Println("Горутина остановлена.")
                return
            default:
                fmt.Println("Горутина работает:", i)
                time.Sleep(1 * time.Second)
                if i == 2 {
                    fmt.Println("Горутина приостановлена.")
                    time.Sleep(3 * time.Second) // Имитация паузы
                    fmt.Println("Горутина продолжает работу.")
                }
            }
        }
    }()

    time.Sleep(5 * time.Second) // Ждем, чтобы увидеть работу горутины
    cancel() // Отмена контекста и остановка горутины

    // Ожидание завершения
    time.Sleep(2 * time.Second)
}

```

_По уроку:_
_1. Функция которая отвечает за отправку в канал вызовет функцию gopark()._
_на же на прямую обращается к планировщику, который и изменяет состояние горутины из running в waiting (ожидание). _
_2. Далее разрывам связь между горутины и потоком (тредом)_
_3. Поток (тред) становиться свободным и планировщик отдает новой горутине наш поток_

## Как разбудить горутину: очередь спящих горутин - sendq

Когда горутина пытается отправить данные в канал, но канал заблокирован (например, если он небуферизированный и никто не читает из него), горутина помещается в очередь спящих горутин, известную как sendq. Эта очередь управляет горутинами, которые ожидают возможности отправить данные в канал.

_По уроку:_
_1. Наша горутина попадает в очередь sendq_

_Sendq представляет собой ссылку на структуру waitq, а структура waitq хранит ссылки на начало и конец связанного списка._

_2. Элементы связанного списка представляют из себя структуру sudog. Грудина попадает в ячейку G, а данные в параметр emel._

_3. Read-ер получает данные из очереди, смещая указатель вправо_

## Что такое связанный список?

Связанный список — это структура данных, состоящая из узлов, где каждый узел содержит данные и ссылку на следующий узел. Это позволяет добавлять и удалять элементы без необходимости перемещения других элементов, как в массивах. Связанные списки удобны для динамического управления памятью и работы с изменяемыми наборами данных.

## Чтение из переполненного канала

Буферизированные каналы позволяют хранить несколько значений до тех пор, пока они не будут прочитаны. Если канал переполнен (т.е. количество отправленных значений больше размера буфера канала), то горутина, пытающаяся отправить данные в этот канал, будет заблокирована до тех пор, пока не появится место в канале для новых данных.

_По уроку:_
_Ресивер пробуждает спящую грудину, помещая данные в буфер._
_Указатель стека смещается вправо, указывая на следующую ячейку._

Пример:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int, 3) // Буферизированный канал размером 3

    // Горутина Sender
    go func() {
        for i := 0; i < 5; i++ {
            fmt.Println("Отправка:", i)
            ch <- i // Блокируется, если канал переполнен
            time.Sleep(1 * time.Second)
        }
        close(ch)
    }()

    // Горутина Receiver
    go func() {
        for value := range ch {
            fmt.Println("Получено:", value)
            time.Sleep(2 * time.Second) // Имитация обработки
        }
    }()

    // Ожидание завершения
    time.Sleep(10 * time.Second)
}

```

## Пробуждение спящей горутины Sender

Когда горутина пытается отправить данные в канал, но канал занят или не может принять данные (например, если он небуферизированный и никто не читает из него), эта горутина блокируется и "засыпает". Однако, когда другая горутина читает данные из этого канала, это может пробудить заблокированную горутину.

_По уроку:_
_Ресивер использует функцию goready() для пробуждения горутины. И меняет состояние спящего горутины на set runnable и тем самым попадает в очередь runq_

Пример:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)

    // Горутина Sender
    go func() {
        for i := 0; i < 5; i++ {
            fmt.Println("Отправка:", i)
            ch <- i // Блокируется, если Receiver не читает
            time.Sleep(time.Second) // Имитация задержки
        }
        close(ch)
    }()

    // Горутина Receiver
    go func() {
        for value := range ch {
            fmt.Println("Получено:", value)
            time.Sleep(2 * time.Second) // Имитация обработки
        }
    }()

    // Ожидание завершения
    time.Sleep(10 * time.Second)
}

```

## Чтение из пустого канала

Когда вы пытаетесь прочитать из пустого канала, операция блокируется до тех пор, пока в канал не будет отправлено значение. Это означает, что goroutine, которая выполняет чтение, будет ждать, пока кто-то не отправит данные в этот канал.

## Передача данных напрямую между стэками двух горутин

Передача данных между горутинами осуществляется через каналы. Когда одна горутина отправляет данные в канал, они фактически передаются из стека одной горутины в стек другой. Это позволяет избежать проблем с конкурентным доступом к данным, поскольку каналы обеспечивают синхронизацию.

Когда данные отправляются в канал, выполнение горутины, отправляющей данные, блокируется до тех пор, пока другая горутина не прочитает эти данные из канала. Таким образом, передача данных происходит безопасно и эффективно, гарантируя, что обе горутины работают с актуальными данными.

## Небуферизированные каналы

Небуферизированные каналы - это каналы, которые не имеют внутреннего хранилища для данных. Это означает, что операция отправки данных в такой канал блокируется до тех пор, пока другая горутина не выполнит операцию чтения из этого канала.

## Преимущества небуферизированных каналов

1. Синхронизация: Они обеспечивают строгую синхронизацию между горутинами. Отправка и получение данных происходит одновременно, что позволяет гарантировать, что данные были получены именно тогда, когда они были отправлены.

2. Простота: Небуферизированные каналы проще в использовании для случаев, когда важно, чтобы отправитель и получатель работали в тесной связке.

Однако использование небуферизированных каналов может привести к блокировкам, если одна из горутин не готова к передаче данных. Поэтому важно правильно проектировать логику работы с горутинами и каналами, чтобы избежать дедлоков.

## Итоги по изучению интересных свойств каналов

-   Каналы безопастны благодаря наличию mutex
-   Хранение элементов и сементика FIFO благодаря буферу канала
-   Предача данных между горутинами благодаря функции sendDirect и операции с буфером
-   Блокировки горутин благодаря sendq/recvq и обращение к планировщику с помощью функции gopark() и goready

## Как работает Select

select — это конструкция, которая позволяет ожидать выполнения операций над несколькими каналами одновременно. Она работает аналогично оператору switch, но вместо значений проверяет готовность каналов.

Когда вы используете select, Go будет блокироваться до тех пор, пока не станет готово одно из условий. Как только одно из условий выполнено (например, данные доступны для чтения из канала или операция записи может быть выполнена), соответствующий блок кода выполняется. Если несколько операций готовы, выбирается случайная из них.

Пример:

```go
select {
    case msg1 := <-channel1:
        fmt.Println("Received:", msg1)
    case msg2 := <-channel2:
        fmt.Println("Received:", msg2)
    case channel3 <- msg:
        fmt.Println("Sent:", msg)
    default:
        fmt.Println("No communication")
}

```

## Закрытие канала

Закрытие канала — это операция, которая сигнализирует о том, что больше не будет отправлено никаких данных в этот канал. Закрытие канала позволяет получателям понять, что больше не будет новых значений, и завершить свою работу.

Чтобы закрыть канал, используется встроенная функция `close(channel)`. После закрытия канала все операции записи в него приведут к панике, но операции чтения будут продолжать работать, возвращая значения до тех пор, пока канал не станет пустым.

## Итоги: почему каналы спроектированны именно так?

Каналы являются решением который стоит между простотой реализации и производительностью. Именно по этому данный материал идет волнами сложно понять -> легко и так далее. Главное - понять суть работы, наличие тех или иных функций, зачем они нужны и для чего используются!
